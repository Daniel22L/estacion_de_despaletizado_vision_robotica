<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.2.2">
<procedure name="main">
<interface/>
<body>
<c>*CONEXION CON LA CAMARA</c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2,1]" as_ord="1">open_framegrabber ('uEye', 1, 1, 0, 0, 0, 0, 'default', 8, 'default', -1, 'false', 'default', '1', 0, -1, AcqHandle)</l>
<l>set_framegrabber_param (AcqHandle, 'exposure', 3)</l>
<l>grab_image_start (AcqHandle, -1)</l>
<c></c>
<c></c>
<c>*datos de calibracion</c>
<l>*CameraParameters := ['area_scan_division',0.0136259,-69.9262,3.45507e-006,3.45e-006,2016.29,1488.89,4104,3006]</l>
<l>*CameraPose := [0.240531,-0.0155894,0.682759,1.28585,358.866,89.1027,0]</l>
<c></c>
<l>*calibracion:=240/1445.59</l>
<l>calibracion:=1/5.80935</l>
<c></c>
<c>*CONEXION CON EL PLC    </c>
<c>*IP y puerto opc ua del PLC</c>
<l>MyOpcUaIP := '172.16.131.228'</l>
<l>MyOpcUaPortNumber := 4840</l>
<l>MyOpcUaServer := 'opc.tcp://' + MyOpcUaIP + ':' + MyOpcUaPortNumber</l>
<c>    </c>
<c>* Open the connection to the server</c>
<l>open_io_device ('OPC_UA', MyOpcUaServer, [], [], IoDeviceHandle)</l>
<c>*******************************************************************************************</c>
<c>*Metodo de comunicaciones. Abrir canal --&gt;leer/escribir variable --&gt; cerrar canal</c>
<c>*Multiplico por 100 los datos en mm para guardarlos en el PLC como DInt y conservando 2 decimales</c>
<c></c>
<c>*abro comunicaciones</c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."inicializacion"', [], [], inicializacion)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."reconoce_pale"', [], [], reconoce_pale)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."reconoce_piezas"', [], [], reconoce_piezas)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."envia_datos"', [], [], envia_datos)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."prepara_datos"', [], [], prepara_datos)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."A"."finaliza"', [], [], finaliza)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."inicializado"', [], [], inicializado)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."pale_reconocido"', [], [], pale_reconocido)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."piezas_reconocidas"', [], [], piezas_reconocidas)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."finalizado"', [], [], finalizado)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."datos_actualizados"', [], [], datos_actualizados)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."ESTADOS"."datos_preparados"', [], [], datos_preparados)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."distancia_vision"', [], [], distancia_vision)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PALE"."Y"', [], [], paleY)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PALE"."X"', [], [], paleX)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PALE"."C"', [], [], paleC)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PIEZAS".no_piezas', [], [], no_piezas)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PIEZAS"."X"', [], [], piezasX)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PIEZAS"."Y"', [], [], piezasY)</l>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PIEZAS"."C"', [], [], piezasC)</l>
<c></c>
<l>open_io_channel (IoDeviceHandle, 'ns=3;s="OPC_VISION"."DE"."PIEZAS".numero', [], [], numero_piezas)</l>
<c></c>
<c></c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,2]" as_ord="1">while (true)</l>
<c>   </c>
<c>    *Captura imagen de la camara. Lo hago aqui fuera porque si lo hago despues de recibir una orden, no coge la imagen actualizada</c>
<l>    grab_image_async (Image, AcqHandle, -1) </l>
<c></c>
<c>            </c>
<l>   * dev_display (Image)</l>
<l>*     read_image (Image, 'C:/Users/DLN/Documents/Vision artificial/Imagenes/Tablas')</l>
<c>    *centro de la imagen. Las coordenadas de los puntos se envian relativos a este centro</c>
<l>    area_center (Image, Area1, cam_row, cam_colum)</l>
<l>    gen_cross_contour_xld (Cross_center, cam_row, cam_colum, 64, 0.5)</l>
<l>    dev_display (Cross_center) </l>
<c>    </c>
<c>        </c>
<c>    *Lectura ordenes del PLC</c>
<c>    *inicializacion</c>
<c>    </c>
<l>    read_io_channel (inicializacion, DI_inicializacion, Status)</l>
<l>    *close_io_channel (inicializacion)</l>
<c>    </c>
<c>    *reconoce_pale</c>
<c>    </c>
<l>    read_io_channel (reconoce_pale, DI_reconoce_pale, Status)</l>
<l>    *close_io_channel (reconoce_pale)</l>
<c>    </c>
<c>    *reconoce_piezas</c>
<c>    </c>
<l>    read_io_channel (reconoce_piezas, DI_reconoce_piezas, Status)</l>
<l>    *close_io_channel (reconoce_piezas)</l>
<c>    </c>
<c>    *evnia_datos</c>
<c>    </c>
<l>    read_io_channel (envia_datos, DI_envia_datos, Status)</l>
<l>    *close_io_channel (envia_datos)</l>
<c>    </c>
<c>    *prepara_datos</c>
<c>    </c>
<l>    read_io_channel (prepara_datos, DI_prepara_datos, Status)</l>
<l>    *close_io_channel (prepara_datos)</l>
<c>    </c>
<c>    *finaliza</c>
<c>    </c>
<l>    read_io_channel (finaliza, DI_finaliza, Status)</l>
<l>    *close_io_channel (finaliza)</l>
<c>    </c>
<c>    *********************************************************************************************************</c>
<c>    </c>
<c>    *el plc manda una orden. Tengo que poner en la comparacion 'true' porque es asi como la guarda. Si pongo true o no pongo nada o 1 no funciona</c>
<l>    if (DI_inicializacion='true' or DI_reconoce_pale='true' or DI_reconoce_piezas='true' or DI_envia_datos='true' or DI_prepara_datos='true' or DI_finaliza='true')  </l>
<c>        *Pongo a 0 todos los estados, indicandoselo al PLC</c>
<l>        grab_image_async (Image, AcqHandle, -1) </l>
<c>        *inicializado</c>
<c>        </c>
<l>        write_io_channel (inicializado, 0, Status)</l>
<l>        *close_io_channel (inicializado)</l>
<c>        </c>
<c>        *pale_reconocido</c>
<c>        </c>
<l>        write_io_channel (pale_reconocido, 0, Status)</l>
<l>        *close_io_channel (pale_reconocido)</l>
<c>        </c>
<c>        *piezas_reconocidas</c>
<c>        </c>
<l>        write_io_channel (piezas_reconocidas, 0, Status)</l>
<l>        *close_io_channel (piezas_reconocidas)</l>
<c>        </c>
<c>        *finalizado</c>
<c>        </c>
<l>        write_io_channel (finalizado, 0, Status)</l>
<l>        *close_io_channel (finalizado)</l>
<c>        </c>
<c>        *datos_actualizados</c>
<c>        </c>
<l>        write_io_channel (datos_actualizados, 0, Status)</l>
<l>        *close_io_channel (datos_actualizados)</l>
<c>        </c>
<c>        *datos_preparados</c>
<c>        </c>
<l>        write_io_channel (datos_preparados, 0, Status)</l>
<l>        *close_io_channel (datos_preparados)</l>
<c>        </c>
<c>        *************************************************************************************************************</c>
<c>        </c>
<c>        </c>
<l>        if (DI_inicializacion='true')</l>
<c>            </c>
<c>            *parte grafica</c>
<l>            dev_clear_window ()</l>
<c>            *ajusto el tamaño de la pantalla</c>
<l>            *dev_resize_window_fit_image (Image, 0, 0, -1, -1)</l>
<c>             </c>
<c>            *inicio unos vectores para usarlos en reconocer piezas</c>
<l>            tuple_gen_const (0, 0, filas)</l>
<l>            tuple_gen_const (0, 0, cols)</l>
<l>            tuple_gen_const (0, 0, orient)</l>
<c>            </c>
<c>            </c>
<c>            *distancia a la que poisiocnar la camara</c>
<c>            </c>
<l>            write_io_channel (distancia_vision, 591*100, Status)</l>
<l>           * close_io_channel (distancia_vision)</l>
<c>            </c>
<c>            </c>
<c>            *COMUNICO CON EL PLC.Pongo a 1 inicializado</c>
<c>            </c>
<l>            write_io_channel (inicializado, 1, Status)</l>
<l>            *close_io_channel (inicializado)</l>
<c>            </c>
<l>        elseif (DI_reconoce_pale='true')</l>
<l>            grab_image_async (Image, AcqHandle, -1) </l>
<l>            dev_clear_window ()</l>
<c>            </c>
<c>            *Busco el pale</c>
<l>            Reconocer_pale (Image, pale, pale_row1, pale_column1, pale_row, pale_colum, pale_angulo)</l>
<l>            dev_display (Image)</l>
<l>            dev_display (Cross_center)</l>
<l>            Dibujar_contorno (pale) </l>
<c>            </c>
<c>            *coordenadas con respecto a la camara en mm</c>
<l>            *image_points_to_world_plane (CameraParameters, CameraPose, pale_row, pale_colum, 'mm', World_Row_pale, World_Col_pale)</l>
<l>            pale_row:=pale_row-cam_row</l>
<l>            pale_colum:=pale_colum-cam_colum</l>
<c>            </c>
<l>            World_Row_pale:=calibracion*pale_row</l>
<l>            World_Col_pale:=calibracion*pale_colum</l>
<c>             </c>
<c>            *COMUNICACOINES CON EL PLC</c>
<c>            *pale_row</c>
<c>            </c>
<l>            write_io_channel (paleY, World_Row_pale*100, Status)</l>
<l>            *close_io_channel (paleY)</l>
<c>            </c>
<c>            *pale_colum</c>
<c>            </c>
<l>            write_io_channel (paleX, World_Col_pale*100, Status)</l>
<l>            *close_io_channel (paleX)</l>
<c>            </c>
<c>            *angulo pale</c>
<c>            </c>
<l>            write_io_channel (paleC, -pale_angulo*100, Status)</l>
<l>            *close_io_channel (paleC)</l>
<c>            </c>
<c>            *pongo a 1 pale_reconocido</c>
<c>           </c>
<l>            write_io_channel (pale_reconocido, 1, Status)</l>
<l>            *close_io_channel (pale_reconocido)</l>
<c>            </c>
<l>        elseif (DI_reconoce_piezas='true')</l>
<l>            grab_image_async (Image, AcqHandle, -1) </l>
<l>            dev_clear_window ()</l>
<c>            </c>
<c>            *Busco el pale</c>
<l>            Reconocer_pale (Image, pale, pale_row1, pale_column1, pale_row2, pale_column2, phi)</l>
<l>            dev_display (Image)</l>
<c>            *reduczo la zona de busqueda al pale. ROI en el pale</c>
<l>            reduce_domain (Image, pale, ImageReduced)</l>
<c>            </c>
<c>            *BUSCO LAS PIEZAS</c>
<c>            *metodos para el reconocimiento de piezas</c>
<l>            regiongrowing (ImageReduced, piezas, 1, 1, 8, 100000)</l>
<l>*             regiongrowing_n (ImageReduced, Regions3, 'n-norm', 0.1, 6, 400000)</l>
<l>*             regiongrowing_n (ImageReduced, Regions4, 'n-norm', 1, 9, 400000)</l>
<c>            </c>
<c>            </c>
<c>            *filtra por forma</c>
<l>            select_shape (piezas, piezas, 'rectangularity', 'and', 0.7, 1)</l>
<c>            *filtro por tamaño</c>
<l>            *select_shape (piezas, piezas, 'area', 'and', 100000, 1000000)    </l>
<c>            *cuenta las piezas</c>
<l>            count_obj (piezas, num_piezas)</l>
<c>            </c>
<c>            *pongo a 0 los vectores en los que se guradaron las filas y columnas de los centros</c>
<l>            tuple_gen_const (0, 0, filas)</l>
<l>            tuple_gen_const (0, 0, cols)</l>
<l>            tuple_gen_const (0, 0, orient)</l>
<c>            </c>
<c>            *recorre todas las piezas. Dibuja su contorno y guarda su centro</c>
<l>            for Index := 1 to num_piezas by 1</l>
<c>                </c>
<c>                *selecciono una pieza del vector de regiones</c>
<l>                select_obj (piezas, ObjectSelected, Index)</l>
<c>                *la rectangularizo. Esto lo hago porque se que son rectangulares. Así tengo menos error en el calculo de su centro</c>
<l>                shape_trans (ObjectSelected, pieza_rect, 'rectangle2')</l>
<c>                *Busco su centro</c>
<l>                area_center (pieza_rect, Area, Row, Column)</l>
<c>                *Y su orientacion</c>
<l>                orientation_region (pieza_rect, radianes_medidos)</l>
<l>                grados_medidos:=radianes_medidos*360/(2*3.141592)</l>
<l>                if(grados_medidos &gt; 90)</l>
<l>                    Phi:=grados_medidos-180</l>
<l>                elseif(grados_medidos&lt;-90)</l>
<l>                    Phi:=grados_medidos+180</l>
<l>                else</l>
<l>                    Phi:=grados_medidos</l>
<l>                endif</l>
<c>                </c>
<c>                </c>
<c>                </c>
<c>             </c>
<c>                *coordenadas con respecto a la camara en mm</c>
<l>                *image_points_to_world_plane (CameraParameters, CameraPose, Row, Column, 'mm', World_Row_pieza, World_Col_pieza)</l>
<c>                </c>
<l>                Row:=Row-cam_row</l>
<l>                Column:=Column-cam_colum</l>
<c>                </c>
<l>                World_Row_pieza:=calibracion*Row</l>
<l>                World_Col_pieza:=calibracion*Column</l>
<c>                </c>
<c>                *guardo la posicion del centro en los vectores</c>
<c>                </c>
<l>                tuple_insert (filas, 0, World_Row_pieza, filas)</l>
<l>                tuple_insert (cols, 0, World_Col_pieza, cols)</l>
<l>                tuple_insert (orient, 0, Phi, orient)</l>
<c>                </c>
<l>                Dibujar_contorno (pieza_rect)</l>
<c>                                             </c>
<l>            endfor</l>
<c>            </c>
<c>            *Pongo el valor del indice en 0. Esto se usa para ir mandando los datos de los vectores</c>
<l>            I:=0</l>
<c>            </c>
<c>            *indico si se reconocio alguna pieza o si no hay ninguna</c>
<l>            if (num_piezas&gt;0)</l>
<c>                *numero piezas que faltan por sacar</c>
<c>                </c>
<l>                write_io_channel (no_piezas, 0, Status)</l>
<l>               * close_io_channel (no_piezas)</l>
<l>            else</l>
<c>               </c>
<l>                write_io_channel (no_piezas, 1, Status)</l>
<l>               * close_io_channel (no_piezas)</l>
<l>            endif</l>
<c></c>
<c>            </c>
<c>            *COMUNICACION CON EL PLC</c>
<c>            *pongo a 1 piezas_reconocidas</c>
<c>    </c>
<l>            write_io_channel (piezas_reconocidas, 1, Status)</l>
<l>            *close_io_channel (piezas_reconocidas)</l>
<c>            </c>
<l>        elseif (DI_prepara_datos='true')</l>
<c>            </c>
<c>            *Resto 1 a las piezas que faltan por enviar</c>
<l>            num_piezas:=num_piezas-1</l>
<c>            </c>
<c>            *actualizo el indice del vector</c>
<l>            I:=I+1</l>
<c>            </c>
<c>            *pongo a 1 datos_preparados</c>
<c>         </c>
<l>            write_io_channel (datos_preparados, 1, Status)</l>
<l>            *close_io_channel (datos_preparados)</l>
<c>            </c>
<l>        elseif (DI_envia_datos='true') </l>
<c>            </c>
<c>            *si quedan piezas por mandar mando la siguiente</c>
<l>            if (num_piezas&gt;0)    </l>
<c>                </c>
<c>                *pieza_row</c>
<c>                </c>
<l>                write_io_channel (piezasX, cols[I]*100, Status)</l>
<l>                *close_io_channel (piezasX)</l>
<c>                </c>
<c>                *pieza_colum</c>
<c>                </c>
<l>                write_io_channel (piezasY, filas[I]*100, Status)</l>
<l>                *close_io_channel (piezasY)</l>
<c>                </c>
<c>                *pieza_angulo</c>
<c>                </c>
<l>                write_io_channel (piezasC, -orient[I]*100, Status)</l>
<l>                *close_io_channel (piezasC)</l>
<c>                </c>
<c>                 </c>
<c>            *sino quedan piezas por mandar no mando nada</c>
<l>            else</l>
<c>                </c>
<l>            endif</l>
<c>            </c>
<c>                *pongo a 1 datos_actualizados</c>
<c>        </c>
<l>                write_io_channel (datos_actualizados, 1, Status)</l>
<l>               * close_io_channel (datos_actualizados)</l>
<c>                </c>
<c>            </c>
<c>            *numero piezas que faltan por sacar</c>
<c>            </c>
<l>            write_io_channel (numero_piezas, num_piezas, Status)</l>
<l>            *close_io_channel (numero_piezas)</l>
<c></c>
<c>            </c>
<l>        elseif (DI_finaliza='true')</l>
<c>            </c>
<c>            </c>
<c>            *pongo a 1 finalizado</c>
<c>            </c>
<l>            write_io_channel (finalizado, 1, Status)</l>
<l>            *close_io_channel (finalizado)</l>
<l>        endif</l>
<c>        </c>
<l>    endif</l>
<c></c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[3,1]" as_ord="1">endwhile</l>
<c></c>
<c>*Cierra comunicacion con el PLC y con la camara</c>
<c>*Esto solo se ejuctaria al salir del bucle. Nunca se sale de el.</c>
<l>close_io_device (IoDeviceHandle)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[4,1]" as_ord="1">close_framegrabber (AcqHandle)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="Reconocer_pale">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="pale_rect" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="Row1" base_type="ctrl" dimension="0"/>
<par name="column1" base_type="ctrl" dimension="0"/>
<par name="Row" base_type="ctrl" dimension="0"/>
<par name="Column" base_type="ctrl" dimension="0"/>
<par name="Phi" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c> *con esto funciona pero es mas rapido por grises</c>
<l>* regiongrowing (Image, pale_rect, 10, 10, 5, 1000000)</l>
<c>* busca el pale por nivel de gris ya que el fondo es negro</c>
<l>threshold (Image, Regions, 70, 255)</l>
<c></c>
<c>*abro de forma rectangular</c>
<l>opening_rectangle1 (Regions, pale_rect, 100, 100)</l>
<c></c>
<c>* rectangularizo la forma detectada</c>
<l>shape_trans (pale_rect, pale_rect, 'rectangle2')</l>
<c></c>
<c>*calculo sus medidas</c>
<l>area_center (pale_rect, Area, Row, Column)</l>
<c></c>
<l>orientation_region (pale_rect, radianes_medidos)</l>
<l>grados_medidos:=radianes_medidos*360/(2*3.141592)</l>
<l>if(grados_medidos &gt; 90)</l>
<l>   Phi:=grados_medidos-180</l>
<l>elseif(grados_medidos&lt;-90)</l>
<l>   Phi:=grados_medidos+180</l>
<l>else</l>
<l>   Phi:=grados_medidos</l>
<l>endif</l>
<c></c>
<c></c>
<l>smallest_rectangle1 (pale_rect, Row1, Column1, Row2, Column2)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="Reconocer_pale">
<parameters>
<parameter id="Column"/>
<parameter id="Image"/>
<parameter id="Phi"/>
<parameter id="Row"/>
<parameter id="Row1"/>
<parameter id="column1"/>
<parameter id="pale_rect"/>
</parameters>
</docu>
</procedure>
<procedure name="Dibujar_contorno">
<interface>
<io>
<par name="region" base_type="iconic" dimension="0"/>
</io>
</interface>
<body>
<c>* </c>
<c>* </c>
<l>*orientation_region (region, Phi)</l>
<l>*area_center (region, Area, Row, Column)</l>
<l>*gen_contour_region_xld (region, Contours, 'border')</l>
<c></c>
<c></c>
<c>* me quedo con sus contorno</c>
<l>gen_contour_region_xld (region, Contours, 'border')</l>
<c>* busco el centro</c>
<l>area_center (region, Area, Row, Column)</l>
<c>* genero una X en el centro</c>
<l>gen_cross_contour_xld (Cross, Row, Column, 64, 0.5)</l>
<c>* </c>
<c>* Ahora dibujo</c>
<c>* modifico el ancho de linea</c>
<l>dev_set_line_width (4)</l>
<c>* cambio el color del contorno</c>
<l>dev_set_color ('red')</l>
<c>* dibjo el contorno</c>
<l>dev_display (Contours)</l>
<c>* cambio el color de la X</c>
<l>dev_set_color ('green')</l>
<c>* dibujo la X</c>
<l>dev_display (Cross)</l>
<c>* </c>
<c>* </c>
<l>return ()</l>
</body>
<docu id="Dibujar_contorno">
<parameters>
<parameter id="region"/>
</parameters>
</docu>
</procedure>
<procedure name="Reconocer_pale_COPY_1">
<interface>
<oo>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="piezas_pale" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="pale_row1" base_type="ctrl" dimension="0"/>
<par name="pale_column1" base_type="ctrl" dimension="0"/>
<par name="pale_row2" base_type="ctrl" dimension="0"/>
<par name="pale_column2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* saca la foto</c>
<l>read_image (Image, 'C:/Users/DLN/Documents/Vision artificial/tablas.tif')</l>
<l>rgb1_to_gray (Image, GrayImage)</l>
<c>* </c>
<c>* intento buscar el pale con la siguiente funcion cunado tenga un mejor contraste con el fondo</c>
<l>* regiongrowing (Image, piezas_pale, 10, 10, 5, 1000000)</l>
<c>* busca el pale.</c>
<c>* </c>
<l>threshold (GrayImage, Regions, 58, 255)</l>
<l>opening_rectangle1 (Regions, piezas_pale, 100, 100)</l>
<c>* </c>
<c>* saco las medidas del pale</c>
<l>smallest_rectangle1 (piezas_pale, pale_row1, pale_column1, pale_row2, pale_column2)</l>
<c>* </c>
<c>* </c>
<c>* No genero un rectangulo sino que me quedo con piezas_pale. Así elimino el fondo del pale cunado se vea</c>
<l>return ()</l>
</body>
<docu id="Reconocer_pale_COPY_1">
<parameters>
<parameter id="Image"/>
<parameter id="pale_column1"/>
<parameter id="pale_column2"/>
<parameter id="pale_row1"/>
<parameter id="pale_row2"/>
<parameter id="piezas_pale"/>
</parameters>
</docu>
</procedure>
</hdevelop>
